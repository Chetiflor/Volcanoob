#pragma kernel Prediction
#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel CalculateDensity
#pragma kernel CalculatePressureForce
#pragma kernel UpdatePosition
#pragma kernel CalculateLaplacians
// #pragma kernel CalculateDeltaTemperature
#pragma kernel UpdateTemperature

// Includes
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int NumThreads = 64;

// Buffers
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> PredictedPositions;
RWStructuredBuffer<float3> Accelerations;
RWStructuredBuffer<float3> k1;
RWStructuredBuffer<float3> k2;
RWStructuredBuffer<float3> k3;
RWStructuredBuffer<float3> k4;
RWStructuredBuffer<float> h1;
RWStructuredBuffer<float> h2;
RWStructuredBuffer<float> h3;
RWStructuredBuffer<float> h4;
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float3> PredictedVelocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density
RWStructuredBuffer<uint3> SpatialIndices; // used for spatial hashing
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing
RWStructuredBuffer<float> Temperatures; 
RWStructuredBuffer<float> DeltaTemperatures; 
RWStructuredBuffer<float3> PredictedTemperaturesViscositiesConductivitiesBuffer;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float3 boundsSize;
const float3 centre;
const float3 thermostatPosition;
const float thermostatTemperature;
const float thermostatDensity;
const float thermostatConductivity;

const float4x4 localToWorld;
const float4x4 worldToLocal;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearDensity * nearPressureMultiplier;
}

void ResolveCollisions(uint particleIndex)
{
	// Transform position/velocity to the local space of the bounding box (scale not included)
	float3 posLocal = mul(worldToLocal, float4(Positions[particleIndex], 1)).xyz;
	float3 velocityLocal = mul(worldToLocal, float4(Velocities[particleIndex], 0)).xyz;

	// Calculate distance from box on each axis (negative values are inside box)
	const float3 halfSize = 0.5;
	const float3 edgeDst = halfSize - abs(posLocal);

	// Resolve collisions
	if (edgeDst.x <= 0)
	{
		posLocal.x = halfSize.x * sign(posLocal.x);
		velocityLocal.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		posLocal.y = halfSize.y * sign(posLocal.y);
		velocityLocal.y *= -1 * collisionDamping;
	}
	if (edgeDst.z <= 0)
	{
		posLocal.z = halfSize.z * sign(posLocal.z);
		velocityLocal.z *= -1 * collisionDamping;
	}

	// Transform resolved position/velocity back to world space
	Positions[particleIndex] = mul(localToWorld, float4(posLocal, 1)).xyz;
	Velocities[particleIndex] = mul(localToWorld, float4(velocityLocal, 0)).xyz;

}

[numthreads(NumThreads,1,1)]
void Prediction (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Predict
	PredictedVelocities[id.x] = Velocities[id.x] + Accelerations[id.x] * deltaTime;
	PredictedPositions[id.x] = Positions[id.x] + PredictedVelocities[id.x] * deltaTime;
	PredictedTemperaturesViscositiesConductivitiesBuffer[id.x][0] = Temperatures[id.x] + DeltaTemperatures[id.x] * deltaTime;
}

[numthreads(NumThreads,1,1)]
void ExternalForces (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// External forces (gravity)
	Accelerations[id.x] += float3(0, gravity, 0);

}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Reset offsets
	SpatialOffsets[id.x] = numParticles;
	// Update index buffer
	uint index = id.x;
	int3 cell = GetCell3D(PredictedPositions[index], smoothingRadius);
	uint hash = HashCell3D(cell);
	uint key = KeyFromHash(hash, numParticles);
	SpatialIndices[id.x] = uint3(index, hash, key);
}

[numthreads(NumThreads,1,1)]
void CalculateDensity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float3 pos = PredictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = PredictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
		}
	}
	
	Densities[id.x] = float2(density, nearDensity);
}

[numthreads(NumThreads,1,1)]
void CalculatePressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Calculate pressure
	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	float3 pressureForce = 0;
	
	float3 pos = PredictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = PredictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float densityNeighbour = Densities[neighbourIndex][0];
			float nearDensityNeighbour = Densities[neighbourIndex][1];
			float neighbourPressure = PressureFromDensity(densityNeighbour);
			float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

			float sharedPressure = (pressure + neighbourPressure) / 2;
			float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

			float dst = sqrt(sqrDstToNeighbour);
			float3 dir = dst > 0 ? offsetToNeighbour / dst : float3(0, 1, 0);

			pressureForce += dir * DensityDerivative(dst, smoothingRadius) * sharedPressure / densityNeighbour;
			pressureForce += dir * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;
		}
	}
	Accelerations[id.x] += pressureForce/density;
}


[numthreads(NumThreads, 1, 1)]
void UpdatePosition(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	float3 acc=(k1[id.x] + 2*k2[id.x] + 2*k3[id.x] + k4[id.x]);

	Velocities[id.x] += acc * deltaTime / 6;
	Positions[id.x] += Velocities[id.x] * deltaTime;
	k1[id.x]*=0;
	k2[id.x]*=0;
	k3[id.x]*=0;
	k4[id.x]*=0;
	ResolveCollisions(id.x);
	PredictedPositions[id.x]=Positions[id.x];
	PredictedVelocities[id.x]=Velocities[id.x];
}

[numthreads(NumThreads,1,1)]
void CalculateLaplacians (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
		
	float3 pos = PredictedPositions[id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	float3 velocity = PredictedVelocities[id.x];
	float temperature = PredictedTemperaturesViscositiesConductivitiesBuffer[id.x][0];
	float viscosity = PredictedTemperaturesViscositiesConductivitiesBuffer[id.x][1];
	float conductivity = PredictedTemperaturesViscositiesConductivitiesBuffer[id.x][2];
	float density = Densities[id.x];

	// Compute speed laplacian
	float3 velocityLaplacian = (0,0,0);
	float heatFlux = 0;
	for (int dim = 0; dim < 3; dim ++)
	{
		for(int i = 0; i<2;i++)
		{

		
			int3 currOffset = (0,0,0);
			currOffset[dim]=2*i-1;
			float adjacentDensity = 0;
			float3 adjacentVelocity = (0,0,0);
			float adjacentTemperature = 0;
			float adjacentViscosity = 0;
			float adjacentConductivity = 0;
			for (int j = 0; j < 27; j ++)
			{	
				// shoud apply radius*offset on position then getcell and take hash, but equivalent here
				uint hash = HashCell3D(originCell + currOffset + offsets3D[j]);
				uint key = KeyFromHash(hash, numParticles);
				uint currIndex = SpatialOffsets[key];
				while (currIndex < numParticles)
				{
					uint3 indexData = SpatialIndices[currIndex];
					currIndex ++;
					// Exit if no longer looking at correct bin
					if (indexData[2] != key) break;
					// Skip if hash does not match
					if (indexData[1] != hash) continue;

					uint neighbourIndex = indexData[0];

					float3 neighbourPos = PredictedPositions[neighbourIndex];
					float3 offsetToNeighbour = neighbourPos - (pos + currOffset*smoothingRadius);
					float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

					// Skip if not within radius
					if (sqrDstToNeighbour > sqrRadius) continue;

					// Calculate viscosity
					float dst = sqrt(sqrDstToNeighbour);

					float neighbourTemperature = PredictedTemperaturesViscositiesConductivitiesBuffer[neighbourIndex][0];
					float neighbourViscosity = PredictedTemperaturesViscositiesConductivitiesBuffer[neighbourIndex][1];
					float neighbourConductivity = PredictedTemperaturesViscositiesConductivitiesBuffer[neighbourIndex][2];
					float3 neighbourVelocity = PredictedVelocities[neighbourIndex];
					float neighbourDensity = Densities[neighbourIndex][0];

					float tmp =  DensityKernel(dst, smoothingRadius) / neighbourDensity;

					adjacentDensity += neighbourDensity * tmp;
					adjacentVelocity += neighbourVelocity * tmp;
					adjacentTemperature += neighbourTemperature * tmp;
					adjacentViscosity += neighbourViscosity * tmp;
					adjacentConductivity += neighbourConductivity * tmp;

				}

			}
			float sharedConductivity = (density * conductivity + adjacentDensity * adjacentConductivity)/(density+adjacentDensity);
			heatFlux += (adjacentTemperature-temperature) / smoothingRadius * sharedConductivity;

			velocityLaplacian += (adjacentVelocity-velocity);
		}

	}
	Accelerations[id.x] += velocityLaplacian * viscosity / sqrRadius;

	float3 offsetToThermostat = thermostatPosition - pos;
	float sqrDstToThermostat = dot(offsetToThermostat, offsetToThermostat);
	if (sqrDstToThermostat <= sqrRadius)
	{
		float dst=sqrt(sqrDstToThermostat);
		float sharedConductivity = (density * conductivity + thermostatDensity * thermostatConductivity)/(density+thermostatDensity);
		DeltaTemperatures[id.x] = (thermostatTemperature - temperature) / dst * sharedConductivity / density;
		return;
	}
	DeltaTemperatures[id.x] += heatFlux / density;
}




[numthreads(NumThreads, 1, 1)]
void UpdateTemperature(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	Temperatures[id.x]+=(h1[id.x]+2*h2[id.x]+2*h3[id.x]+h4[id.x])*deltaTime/6;
	h1[id.x]=0;
	h2[id.x]=0;
	h3[id.x]=0;
	h4[id.x]=0;
}