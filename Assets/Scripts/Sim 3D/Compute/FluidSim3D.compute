#pragma kernel Prediction
#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel CalculateDensity
#pragma kernel CalculateStateVariables
#pragma kernel PressureForce
#pragma kernel CalculateLaplacians
#pragma kernel UpdateSpatial
#pragma kernel UpdateTemperature

// Includes
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int NumThreads = 64;

// Buffers

RWStructuredBuffer<float3> PositionsVelocities;
RWStructuredBuffer<float3> PredictedPositionsVelocities;

RWStructuredBuffer<float3> RK4Accelerations;
RWStructuredBuffer<float> RK4Heats;

RWStructuredBuffer<float2> Densities; // Density, Near Density

RWStructuredBuffer<uint3> SpatialIndices; // used for spatial hashing
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing

RWStructuredBuffer<float> Temperatures; 
RWStructuredBuffer<float> PredictedTemperatures;

RWStructuredBuffer<float> StateVariables;
const uint stateVariablesStride;
RWStructuredBuffer<float> Constants;
const uint constantsStride;

// Settings
const uint RK4step;

const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float particleDimension;
const float3 boundsSize;
const float3 centre;
const float molesByParticule;
const float4x4 localToWorld;
const float4x4 worldToLocal;

const float3 thermostatPosition;
const float thermostatTemperature;
const float thermostatDensity;
const float thermostatConductivity;
const float R; //universal gas constant
const float ahtmospherePressure;
const float airDensity;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float VDWPressureFromDensityTemperature(float rho, float T, float M, float a, float b)
{
	float x = rho / M;
	if(b*x==1)
	{
		return 1.f;
	}
	return x * (R * T / (1 - b * x) - a * x);
}

float NearPressureFromDensity(float nearDensity)
{
	return nearDensity * nearPressureMultiplier;
}

void ResolveCollisions(uint particleIndex)
{
	// Transform position/velocity to the local space of the bounding box (scale not included)
	float3 posLocal = mul(worldToLocal, float4(PositionsVelocities[2*particleIndex], 1)).xyz;
	float3 velocityLocal = mul(worldToLocal, float4(PositionsVelocities[2*particleIndex+1], 0)).xyz;

	// Calculate distance from box on each axis (negative values are inside box)
	const float3 halfSize = 0.5;
	const float3 edgeDst = halfSize - abs(posLocal);

	// Resolve collisions
	if (edgeDst.x <= 0)
	{
		posLocal.x = halfSize.x * sign(posLocal.x);
		velocityLocal.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		posLocal.y = halfSize.y * sign(posLocal.y);
		velocityLocal.y *= -1 * collisionDamping;
	}
	if (edgeDst.z <= 0)
	{
		posLocal.z = halfSize.z * sign(posLocal.z);
		velocityLocal.z *= -1 * collisionDamping;
	}

	// Transform resolved position/velocity back to world space
	PositionsVelocities[2*particleIndex] = mul(localToWorld, float4(posLocal, 1)).xyz;
	PositionsVelocities[2*particleIndex+1] = mul(localToWorld, float4(velocityLocal, 0)).xyz;

}

[numthreads(NumThreads,1,1)]
void Prediction (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Predict
	PredictedPositionsVelocities[2*id.x+1] = PositionsVelocities[2*id.x+1] + RK4Accelerations[4*id.x+RK4step] * deltaTime;
	PredictedPositionsVelocities[2*id.x] = PositionsVelocities[2*id.x] + PredictedPositionsVelocities[2*id.x+1] * deltaTime;
	PredictedTemperatures[id.x] = Temperatures[id.x] + RK4Heats[4*id.x+RK4step] * deltaTime;
}

[numthreads(NumThreads,1,1)]
void ExternalForces (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// External forces (gravity)
	RK4Accelerations[4*id.x+RK4step] += float3(0, gravity, 0);

}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Reset offsets
	SpatialOffsets[id.x] = numParticles;
	// Update index buffer
	uint index = id.x;
	int3 cell = GetCell3D(PredictedPositionsVelocities[2*index], smoothingRadius);
	uint hash = HashCell3D(cell);
	uint key = KeyFromHash(hash, numParticles);
	SpatialIndices[id.x] = uint3(index, hash, key);
}

[numthreads(NumThreads,1,1)]
void CalculateDensity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius; 
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			//float neighbourVolumicMass = molesByParticule * Constants[neighbourIndex];
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
		}
	}
	Densities[id.x] = float2(density, nearDensity);
}


[numthreads(NumThreads,1,1)]
void CalculateStateVariables (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius; 
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			float neighbourVolumicMass = molesByParticule * Constants[neighbourIndex];
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
		}
	}
	int tmpIndex = constantsStride*id.x;
	float pressure = VDWPressureFromDensityTemperature(density*molesByParticule * Constants[tmpIndex],PredictedTemperatures[id.x],Constants[tmpIndex],Constants[tmpIndex+1],Constants[tmpIndex+2]);
	StateVariables[stateVariablesStride*id.x]=pressure;
}


// void CalculateDensity (uint3 id : SV_DispatchThreadID)
// {
// 	if (id.x >= numParticles) return;

// 	float3 pos = PredictedPositionsVelocities[2*id.x];
// 	int3 originCell = GetCell3D(pos, smoothingRadius);
// 	float sqrRadius = smoothingRadius * smoothingRadius;
// 	float density = 0;
// 	float nearDensity = 0;

// 	// Neighbour search
// 	for (int i = 0; i < 27; i ++)
// 	{
// 		uint hash = HashCell3D(originCell + offsets3D[i]);
// 		uint key = KeyFromHash(hash, numParticles);
// 		uint currIndex = SpatialOffsets[key];

// 		while (currIndex < numParticles)
// 		{
// 			uint3 indexData = SpatialIndices[currIndex];
// 			currIndex ++;
// 			// Exit if no longer looking at correct bin
// 			if (indexData[2] != key) break;
// 			// Skip if hash does not match
// 			if (indexData[1] != hash) continue;

// 			uint neighbourIndex = indexData[0];
// 			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
// 			float3 offsetToNeighbour = neighbourPos - pos;
// 			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

// 			// Skip if not within radius
// 			if (sqrDstToNeighbour > sqrRadius) continue;

// 			// Calculate density and near density
// 			float dst = sqrt(sqrDstToNeighbour);
// 			density += DensityKernel(dst, smoothingRadius);
// 			nearDensity += NearDensityKernel(dst, smoothingRadius);
// 		}
// 	}
	
// 	DensitiesPressures[id.x] = float4(density, nearDensity,PressureFromDensity(density),NearPressureFromDensity(nearDensity));
// }

[numthreads(NumThreads,1,1)]
void PressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Calculate pressure
	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	float3 pressureForce = 0;
	
	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		bool foundNeighbour = false;

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;
			foundNeighbour=true;
			float dst = sqrt(sqrDstToNeighbour);

			// Calculate pressure force
			float densityNeighbour = Densities[neighbourIndex][0];
			float nearDensityNeighbour = Densities[neighbourIndex][1];
			float neighbourPressure = PressureFromDensity(densityNeighbour);
			float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

			float sharedPressure = (pressure + neighbourPressure) / 2;
			float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

			float deltaPressure = (neighbourPressure - pressure) * DensityKernel(dst, smoothingRadius);

			float3 dir = dst > 0 ? offsetToNeighbour / dst : float3(0, 1, 0);

			pressureForce += dir * DensityDerivative(dst, smoothingRadius) * sharedPressure / densityNeighbour; //normalize by neighbour density
			//pressureForce += dir * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;
		}
		// if (!foundNeighbour)
		// {
		// 	float dst = sqrt(float(dot(offsets3D[i],offsets3D[i])));
		// 	if(dst!=0)
		// 	{

		// 		float3 dir = (float3)offsets3D[i]/dst; // in same cell, should find itself ?
		// 		float sharedPressure = (pressure + ahtmospherePressure) / 2 ;
		// 		pressureForce -= dir * DensityDerivative(0, smoothingRadius) * sharedPressure / airDensity * particleDimension * particleDimension * 4 * 3.14;
		// 	}
		// }
	}
	RK4Accelerations[4*id.x+RK4step] += pressureForce/density;
}

[numthreads(NumThreads,1,1)]
void CalculateLaplacians (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
		
	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	
	float density = Densities[id.x][0];
	float3 velocity = PredictedPositionsVelocities[2*id.x+1];
	float temperature = PredictedTemperatures[id.x];

	int tmpIndex = stateVariablesStride * id.x;
	float viscosity = StateVariables[tmpIndex + 2];
	float conductivity = StateVariables[tmpIndex + 3];
	float capacity = StateVariables[tmpIndex + 4];

	// Compute speed laplacian
	float3 velocityLaplacian = (0,0,0);
	float heatFlux = 0;
	for (int dim = 0; dim < 3; dim ++)
	{
		for(int i = 0; i<2;i++)
		{

		
			int3 currOffset = (0,0,0);
			currOffset[dim]=2*i-1;

			float adjacentDensity = 0;
			float3 adjacentVelocity = (0,0,0);
			float adjacentTemperature = 0;
			float adjacentViscosity = 0;
			float adjacentConductivity = 0;

			for (int j = 0; j < 27; j ++)
			{	
				// shoud apply radius*offset on position then getcell and take hash, but equivalent here
				uint hash = HashCell3D(originCell + currOffset + offsets3D[j]);
				uint key = KeyFromHash(hash, numParticles);
				uint currIndex = SpatialOffsets[key];
				while (currIndex < numParticles)
				{
					uint3 indexData = SpatialIndices[currIndex];
					currIndex ++;
					// Exit if no longer looking at correct bin
					if (indexData[2] != key) break;
					// Skip if hash does not match
					if (indexData[1] != hash) continue;

					uint neighbourIndex = indexData[0];
					float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
					float3 offsetToNeighbour = neighbourPos - (pos + currOffset*particleDimension);
					float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

					// Skip if not within radius
					if (sqrDstToNeighbour > sqrRadius) continue;

					// Calculate viscosity
					float dst = sqrt(sqrDstToNeighbour);

					float neighbourDensity = Densities[neighbourIndex][0];
					float3 neighbourVelocity = PredictedPositionsVelocities[2*neighbourIndex+1];
					float neighbourTemperature = PredictedTemperatures[neighbourIndex];

					int tmpNeighbourIndex = neighbourIndex * stateVariablesStride;
					float neighbourViscosity = StateVariables[tmpNeighbourIndex + 2];
					float neighbourConductivity = StateVariables[tmpNeighbourIndex + 3];


					float tmp =  DensityKernel(dst, smoothingRadius) / neighbourDensity;

					adjacentDensity += neighbourDensity * tmp;
					adjacentVelocity += neighbourVelocity * tmp;
					adjacentTemperature += neighbourTemperature * tmp;
					adjacentViscosity += neighbourViscosity * tmp;
					adjacentConductivity += neighbourConductivity * tmp;

				}

			}
			float sharedConductivity = (density * conductivity + adjacentDensity * adjacentConductivity)/(density+adjacentDensity);
			heatFlux += (adjacentTemperature-temperature) * conductivity / (density * capacity * particleDimension * particleDimension);

			velocityLaplacian += (adjacentVelocity-velocity);
		}

	}
	RK4Accelerations[4*id.x+RK4step] += velocityLaplacian * viscosity / (particleDimension*particleDimension) / density;

	float3 offsetToThermostat = thermostatPosition - pos;
	float sqrDstToThermostat = dot(offsetToThermostat, offsetToThermostat);
	if (sqrDstToThermostat <= sqrRadius)
	{
		float dst=sqrt(sqrDstToThermostat);
		float sharedConductivity = (density * conductivity + thermostatDensity * thermostatConductivity)/(density+thermostatDensity);
		RK4Heats[4*id.x+RK4step] = (thermostatTemperature - temperature) / dst * sharedConductivity / density / deltaTime;
		return;
	}
	RK4Heats[4*id.x+RK4step] += heatFlux;
}

[numthreads(NumThreads, 1, 1)]
void UpdateSpatial(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	float3 acc=(RK4Accelerations[4*id.x] + 2*RK4Accelerations[4*id.x+1] + 2*RK4Accelerations[4*id.x+2] + RK4Accelerations[4*id.x+3]) / 6;

	PositionsVelocities[2*id.x+1] += acc * deltaTime;
	PositionsVelocities[2*id.x] += PositionsVelocities[2*id.x+1] * deltaTime;
	RK4Accelerations[4*id.x]=0;
	RK4Accelerations[4*id.x+1]=0;
	RK4Accelerations[4*id.x+2]=0;
	RK4Accelerations[4*id.x+3]=0;
	ResolveCollisions(id.x);
	PredictedPositionsVelocities[2*id.x]=PositionsVelocities[2*id.x];
	PredictedPositionsVelocities[2*id.x+1]=PositionsVelocities[2*id.x+1];
}

[numthreads(NumThreads, 1, 1)]
void UpdateTemperature(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	Temperatures[id.x]+=(RK4Heats[4*id.x]+2*RK4Heats[4*id.x+1]+2*RK4Heats[4*id.x+2]+RK4Heats[4*id.x+3])*deltaTime/6;
	RK4Heats[4*id.x]=0;
	RK4Heats[4*id.x+1]=0;
	RK4Heats[4*id.x+2]=0;
	RK4Heats[4*id.x+3]=0;
}