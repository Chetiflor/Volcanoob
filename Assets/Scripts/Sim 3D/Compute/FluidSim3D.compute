#pragma kernel Prediction
#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel CalculateDensity
#pragma kernel CalculateStateVariables
#pragma kernel PressureForce
#pragma kernel CalculateLaplacians
#pragma kernel UpdateSpatial
#pragma kernel UpdateTemperature

// Includes
#include "./FluidMaths3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int NumThreads = 64;

// Buffers

RWStructuredBuffer<float3> PositionsVelocities;
RWStructuredBuffer<float3> PredictedPositionsVelocities;

RWStructuredBuffer<float3> RK4Accelerations;
RWStructuredBuffer<float> RK4TemperatureDerivative;

RWStructuredBuffer<float2> Densities; // Density, Near Density

RWStructuredBuffer<uint3> SpatialIndices; // used for spatial hashing
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing

RWStructuredBuffer<float> Temperatures; 
RWStructuredBuffer<float> PredictedTemperatures;

RWStructuredBuffer<float> StateVariables;
const uint stateVariablesStride;

// Settings
const uint RK4step;

const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float particleDimension;
const float3 boundsSize;
const float3 centre;
const float molesByParticle;
const float4x4 localToWorld;
const float4x4 worldToLocal;

const float3 thermostatPosition;
const float thermostatTemperature;
const float thermostatInfluenceRadius;
const float R; //universal gas constant
const float ahtmospherePressure;
const float airDensity;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float VDWPressureFromDensityTemperature(float rho, float T, float m, float a, float b)
{
	float x = rho / m * molesByParticle;
	if(b*x==1)
	{
		return 1.f;
	}
	return x * (R * T / (1 - b * x) - a * x);
}

float NearPressureFromDensity(float nearDensity)
{
	return nearDensity * nearPressureMultiplier;
}

void ResolveCollisions(uint particleIndex)
{
	// Transform position/velocity to the local space of the bounding box (scale not included)
	float3 posLocal = mul(worldToLocal, float4(PositionsVelocities[2*particleIndex], 1)).xyz;
	float3 velocityLocal = mul(worldToLocal, float4(PositionsVelocities[2*particleIndex+1], 0)).xyz;

	// Calculate distance from box on each axis (negative values are inside box)
	const float3 halfSize = 0.5;
	const float3 edgeDst = halfSize - abs(posLocal);

	// Resolve collisions
	if (edgeDst.x <= 0)
	{
		posLocal.x = halfSize.x * sign(posLocal.x);
		velocityLocal.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		posLocal.y = halfSize.y * sign(posLocal.y);
		velocityLocal.y *= -1 * collisionDamping;
	}
	if (edgeDst.z <= 0)
	{
		posLocal.z = halfSize.z * sign(posLocal.z);
		velocityLocal.z *= -1 * collisionDamping;
	}

	// Transform resolved position/velocity back to world space
	PositionsVelocities[2*particleIndex] = mul(localToWorld, float4(posLocal, 1)).xyz;
	PositionsVelocities[2*particleIndex+1] = mul(localToWorld, float4(velocityLocal, 0)).xyz;

}

[numthreads(NumThreads,1,1)]
void Prediction (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Predict
	PredictedPositionsVelocities[2*id.x+1] = PositionsVelocities[2*id.x+1] + RK4Accelerations[4*id.x+RK4step] * deltaTime;
	PredictedPositionsVelocities[2*id.x] = PositionsVelocities[2*id.x] + PredictedPositionsVelocities[2*id.x+1] * deltaTime;
	PredictedTemperatures[id.x] = Temperatures[id.x] + RK4TemperatureDerivative[4*id.x+RK4step] * deltaTime;
}

[numthreads(NumThreads,1,1)]
void ExternalForces (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// External forces (gravity)
	RK4Accelerations[4*id.x+RK4step] += float3(0, gravity, 0);

}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Reset offsets
	SpatialOffsets[id.x] = numParticles;
	// Update index buffer
	uint index = id.x;
	int3 cell = GetCell3D(PredictedPositionsVelocities[2*index], smoothingRadius);
	uint hash = HashCell3D(cell);
	uint key = KeyFromHash(hash, numParticles);
	SpatialIndices[id.x] = uint3(index, hash, key);
}

[numthreads(NumThreads,1,1)]
void CalculateDensity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius; 
	float mass = StateVariables[stateVariablesStride * id.x + 5];
	float density = 0;
	float nearDensity = 0;
	

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			float neighbourVolumicMass = StateVariables[stateVariablesStride * neighbourIndex + 5] / (4 / 3 * PI * particleDimension * particleDimension * particleDimension);
			
			density += DensityKernel(dst, smoothingRadius) * neighbourVolumicMass;
			nearDensity += NearDensityKernel(dst, smoothingRadius) * neighbourVolumicMass;
		}
	}
	Densities[id.x] = float2(density, density/mass);
}


[numthreads(NumThreads,1,1)]
void CalculateStateVariables (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	float density = Densities[id.x][0];

	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius; 

	int tmpIndex = stateVariablesStride*id.x;
	StateVariables[tmpIndex] = VDWPressureFromDensityTemperature(Densities[id.x][0],PredictedTemperatures[id.x],StateVariables[tmpIndex+5],StateVariables[tmpIndex+6],StateVariables[tmpIndex+7]);
	//StateVariables[tmpIndex] =	PressureFromDensity(density);
}




[numthreads(NumThreads,1,1)]
void PressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// Calculate pressure
	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density);
	//float pressure = StateVariables[stateVariablesStride * id.x];
	float nearPressure = NearPressureFromDensity(densityNear);
	float3 pressureForce = 0;
	
	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell3D(originCell + offsets3D[i]);
		uint key = KeyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		bool foundNeighbour = false;

		while (currIndex < numParticles)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;
			foundNeighbour=true;
			float dst = sqrt(sqrDstToNeighbour);

			// Calculate pressure force
			float densityNeighbour = Densities[neighbourIndex][0];
			float nearDensityNeighbour = Densities[neighbourIndex][1];
			float neighbourPressure = PressureFromDensity(densityNeighbour);
			// float neighbourPressure = StateVariables[stateVariablesStride * neighbourIndex];
			float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

			float sharedPressure = (pressure + neighbourPressure) / 2;
			float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

			float neighbourVolumicMass = StateVariables[stateVariablesStride * neighbourIndex + 5] / (4 / 3 * PI * particleDimension * particleDimension * particleDimension);
			float deltaPressure = (neighbourPressure - pressure) * DensityKernel(dst, smoothingRadius) * neighbourVolumicMass;

			float3 dir = dst > 0 ? offsetToNeighbour / dst : float3(0, 1, 0);

			pressureForce += dir * DensityDerivative(dst, smoothingRadius) * sharedPressure / densityNeighbour * neighbourVolumicMass; //normalize by neighbour density
			//pressureForce += dir * deltaPressure;
			//pressureForce += dir * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;
		}
		// if (!foundNeighbour)
		// {
		// 	float dst = sqrt(float(dot(offsets3D[i],offsets3D[i])));
		// 	if(dst!=0)
		// 	{

		// 		float3 dir = (float3)offsets3D[i]/dst; // in same cell, should find itself ?
		// 		float sharedPressure = (pressure + ahtmospherePressure) / 2 ;
		// 		pressureForce -= dir * DensityDerivative(0, smoothingRadius) * sharedPressure / airDensity * particleDimension * particleDimension * 4 * 3.14;
		// 	}
		// }
	}
	RK4Accelerations[4*id.x+RK4step] += pressureForce/density;
}

[numthreads(NumThreads,1,1)]
void CalculateLaplacians (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
		
	float3 pos = PredictedPositionsVelocities[2*id.x];
	int3 originCell = GetCell3D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float sqrDx = particleDimension * particleDimension;
	
	float density = Densities[id.x][0];
	float volInv = Densities[id.x][1];
	float3 velocity = PredictedPositionsVelocities[2*id.x+1];
	float temperature = PredictedTemperatures[id.x];

	int tmpIndex = stateVariablesStride * id.x;
	float viscosity = StateVariables[tmpIndex + 2];
	float conductivity = StateVariables[tmpIndex + 3];
	float capacity = StateVariables[tmpIndex + 4];
	float mass = StateVariables[tmpIndex + 5];

	// Compute laplacians and convective term
	float3 velocityLaplacian = (0,0,0);
	float3 convectiveTerm = (0,0,0);
	float3 pressureGradient = (0,0,0);
	float temperatureLaplacian = 0;	

	for (int dim = 0; dim < 3; dim ++)
	{
		for(int i = 0; i<2;i++)
		{

		
			int3 currOffset = (0,0,0);
			int sign=2*i-1;
			currOffset[dim]=sign;

			float3 adjacentVelocity = (0,0,0);
			float adjacentPressure = 0;
			float adjacentTemperature = 0;

			for (int j = 0; j < 27; j ++)
			{	
				int3 offsetCell = GetCell3D(pos + currOffset*particleDimension, smoothingRadius);
				uint hash = HashCell3D(offsetCell  + offsets3D[j]);
				uint key = KeyFromHash(hash, numParticles);
				int currIndex = SpatialOffsets[key];
				while (currIndex < numParticles)
				{
					uint3 indexData = SpatialIndices[currIndex];
					currIndex ++;
					// Exit if no longer looking at correct bin
					if (indexData[2] != key) break;
					// Skip if hash does not match
					if (indexData[1] != hash) continue;

					uint neighbourIndex = indexData[0];
					float3 neighbourPos = PredictedPositionsVelocities[2*neighbourIndex];
					float3 offsetToNeighbour = neighbourPos - (pos + currOffset*particleDimension);
					float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

					// Skip if not within radius
					if (sqrDstToNeighbour > sqrRadius) continue;

					// Calculate viscosity
					float dst = sqrt(sqrDstToNeighbour);

					float neighbourDensity = Densities[neighbourIndex][0];
					float3 neighbourVelocity = PredictedPositionsVelocities[2*neighbourIndex+1];
					float neighbourTemperature = PredictedTemperatures[neighbourIndex];
					tmpIndex = stateVariablesStride*neighbourIndex;
					float neighbourPressure = StateVariables[tmpIndex];
					float neighbourMass = StateVariables[tmpIndex + 5];

					float tmp =  DensityKernel(dst, smoothingRadius) / neighbourDensity * neighbourMass / (4 / 3 * PI * particleDimension * particleDimension * particleDimension);

					adjacentVelocity += neighbourVelocity * tmp;
					adjacentTemperature += neighbourTemperature * tmp;
					adjacentPressure += neighbourPressure * tmp;

				}


			}
			temperatureLaplacian += (adjacentTemperature-temperature) ;
			pressureGradient[dim] += sign*adjacentPressure;
			convectiveTerm += sign*(adjacentVelocity)*velocity[dim];
			velocityLaplacian += (adjacentVelocity-velocity);
		}

	}
	RK4Accelerations[4*id.x+RK4step] += velocityLaplacian * viscosity / (sqrDx * density);
	RK4Accelerations[4*id.x+RK4step] -= convectiveTerm / (2 * particleDimension * density);
	//RK4Accelerations[4*id.x+RK4step] -= pressureGradient / (2 * particleDimension * density);

	float3 offsetToThermostat = thermostatPosition - pos;
	float sqrDstToThermostat = dot(offsetToThermostat, offsetToThermostat);
	float dst=sqrt(sqrDstToThermostat);
	if (dst <= thermostatInfluenceRadius)
	{
		float closeTemperature = DensityKernel(max(dst - particleDimension,0), thermostatInfluenceRadius) * thermostatTemperature;
		float farTemperature = DensityKernel(dst + particleDimension, thermostatInfluenceRadius) * thermostatTemperature;
		temperatureLaplacian += (closeTemperature + farTemperature - 2*temperature);
	}
	RK4TemperatureDerivative[4*id.x+RK4step] += temperatureLaplacian * conductivity / (density * capacity * sqrDx);
}

[numthreads(NumThreads, 1, 1)]
void UpdateSpatial(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	float3 acc=(RK4Accelerations[4*id.x] + 2*RK4Accelerations[4*id.x+1] + 2*RK4Accelerations[4*id.x+2] + RK4Accelerations[4*id.x+3]) / 6;

	PositionsVelocities[2*id.x+1] += acc * deltaTime;
	PositionsVelocities[2*id.x] += PositionsVelocities[2*id.x+1] * deltaTime;
	RK4Accelerations[4*id.x]=0;
	RK4Accelerations[4*id.x+1]=0;
	RK4Accelerations[4*id.x+2]=0;
	RK4Accelerations[4*id.x+3]=0;
	ResolveCollisions(id.x);
	PredictedPositionsVelocities[2*id.x]=PositionsVelocities[2*id.x];
	PredictedPositionsVelocities[2*id.x+1]=PositionsVelocities[2*id.x+1];
}

[numthreads(NumThreads, 1, 1)]
void UpdateTemperature(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	Temperatures[id.x]+=(RK4TemperatureDerivative[4*id.x]+2*RK4TemperatureDerivative[4*id.x+1]+2*RK4TemperatureDerivative[4*id.x+2]+RK4TemperatureDerivative[4*id.x+3])*deltaTime/6;
	RK4TemperatureDerivative[4*id.x]=0;
	RK4TemperatureDerivative[4*id.x+1]=0;
	RK4TemperatureDerivative[4*id.x+2]=0;
	RK4TemperatureDerivative[4*id.x+3]=0;
}